<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xmasstream</title>
    
    <!-- Google Font: Cutive Mono (文字描画に使用) -->
    <link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&display=swap" rel="stylesheet">
    
    <!-- Three.jsの読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControlsの読み込み (カメラ操作用) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* 背景を白、描画を黒のモノクローム設定 */
        body {
            background-color: #FFFFFF; /* 背景色を白 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            margin: 0;
            overflow: hidden;
            font-family: 'Cutive Mono', monospace;
            cursor: grab; /* ドラッグ操作を促すカーソル */
            position: relative;
        }
        canvas {
            display: block;
        }
        /* カメラ操作のヒント (削除対象) */
        /* #info {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #000000;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.9rem;
            z-index: 10;
            text-align: center;
            opacity: 0.8;
            user-select: none; 
        } */
    </style>
</head>
<body>
    <!-- 3Dレンダリングコンテナ -->
    <div id="container"></div>

    <!-- 情報オーバーレイ (削除対象) -->
    <!-- <div id="info">MERRY CHRISTMAS STREAM - Drag to rotate view.</div> -->

    <script>
        // --- Three.js グローバル変数 ---
        let scene, camera, renderer, controls;
        let D_W, D_H;
        let charSize;
        
        // --- アートワーク グローバル定数 ---
        // Z軸の奥行き範囲と初期X軸の広がりをグローバル定数として定義
        const DEPTH_RANGE = 800;
        const INITIAL_X_SPREAD = 300; 

        // ストリームデータを格納する配列。各要素は { chars: [], lineGeometry: ... } の構造を持つ
        let characterSets = [];
        // 表示テキスト
        const currentText = "MERRY CHRISTMAS";
        let globalStreamGroup;
        
        // --- デルタタイム関連変数 ---
        let lastTime = 0;
        const FIXED_FPS_FACTOR = 1000 / 60; // 60fps基準の計算

        // --- アニメーション状態 ---
        const globalSpeedFactor = 4.0; // Fast Scroll の速度係数に固定

        // カラーパレット (背景: 白, ライン/文字: 黒)
        const lineColor = 0x000000;
        

        /**
         * 文字を描画したテクスチャを持つ THREE.Sprite を作成する
         * @param {string} text - 描画する文字。
         * @param {number} size - 3D空間での基本サイズ。
         * @param {number} color - 文字色 (0xRRGGBB)。
         * @returns {THREE.Sprite}
         */
        function createSprite(text, size, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Sprite resolution
            const resolution = 64;
            canvas.width = resolution;
            canvas.height = resolution;

            // 'Cutive Mono'フォントを使用
            context.font = `bold ${resolution * 0.8}px 'Cutive Mono', monospace`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // 描画色を黒に設定
            const hexColor = '#' + color.toString(16).padStart(6, '0');
            context.fillStyle = hexColor;

            // 文字を描画
            context.fillText(text, resolution / 2, resolution / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;

            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                color: color 
            });

            const sprite = new THREE.Sprite(material);
            // 3D空間での表示サイズを設定
            sprite.scale.set(size * 2, size * 2, 1);
            return sprite;
        }


        /**
         * 3D環境のセットアップ
         */
        function setupThreeJs() {
            D_W = window.innerWidth;
            D_H = window.innerHeight;

            // Scene
            scene = new THREE.Scene();
            
            // NOTE: フォグ設定を削除しました。
            // scene.fog = new THREE.Fog(0xFFFFFF, 150, 450); // 削除

            // Camera (Perspective)
            camera = new THREE.PerspectiveCamera(75, D_W / D_H, 0.1, 1000);
            camera.position.z = 150; 

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(D_W, D_H);
            renderer.setClearColor(0xFFFFFF); // 背景色を白に設定
            
            const container = document.getElementById('container');
            // 既存のcanvasがあればクリア
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            container.appendChild(renderer.domElement);

            // OrbitControls for camera interaction (ドラッグで回転、スクロールでズーム)
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;

            // Global group for all streams
            globalStreamGroup = new THREE.Group();
            // 初期でグループ全体を傾けることで3D感を強調
            globalStreamGroup.rotation.x = -Math.PI / 16; 
            scene.add(globalStreamGroup);
            
            // Determine base size
            charSize = Math.max(1.0, Math.min(3.0, D_H / 200)); 
            
            initializeCharacters();
        }

        /**
         * 要素セット（ストリーム）を3D空間に初期配置します。
         */
        function initializeCharacters() {
            // 既存のオブジェクトをクリアし、リソースを破棄
            globalStreamGroup.children.forEach(child => child.traverse(object => {
                if (object.geometry) object.geometry.dispose();
                if (object.material) {
                    const materials = Array.isArray(object.material) ? object.material : [object.material];
                    materials.forEach(material => {
                        if (material.map) material.map.dispose(); 
                        material.dispose();
                    });
                }
            }));
            globalStreamGroup.clear();
            characterSets = [];

            if (currentText.trim() === "") return;

            const charLength = currentText.length;
            const numStreams = 20; // ストリーム数を増やして密度を向上
            
            // Line Material (black, low opacity for thin appearance)
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: lineColor, 
                linewidth: 1, 
                transparent: true, 
                opacity: 0.15,
                // フォグと相性が良いようにdepthWriteを無効にする
                depthWrite: false
            });

            for (let i = 0; i < numStreams; i++) {
                const streamGroup = new THREE.Group();
                // ストリームデータを保持する専用のオブジェクト
                const currentStream = {
                    chars: [],
                    lineGeometry: null
                };
                
                // Random initial Z position across the entire range, and X position
                // グローバル定数 DEPTH_RANGE と INITIAL_X_SPREAD を使用
                const initialZOffset = Math.random() * DEPTH_RANGE - DEPTH_RANGE / 2;
                const initialXOffset = Math.random() * INITIAL_X_SPREAD - INITIAL_X_SPREAD / 2;

                // Character generation and placement
                const points = [];
                currentText.split('').forEach((char, index) => {
                    // Y position offset within the stream
                    const initialY = (index - charLength / 2) * charSize * 2.5; 
                    
                    // Base speed
                    const baseSpeed = 0.05 + Math.random() * 0.2; 
                    
                    // Amplitude (subtle movement)
                    const amplitude = Math.random() * 0.5 + 0.2; 
                    const frequency = 0.01 + Math.random() * 0.02; 
                    const movementType = Math.floor(Math.random() * 3);

                    const charObj = {
                        char: char, 
                        pos: new THREE.Vector3(initialXOffset, initialY, initialZOffset),
                        baseY: initialY,  
                        baseVx: baseSpeed,
                        time: Math.random() * 100, 
                        amplitude: amplitude,
                        frequency: frequency,
                        type: movementType,
                        initialPos: new THREE.Vector3(initialXOffset, initialY, initialZOffset),
                        mesh: null // 3D Object (Sprite)
                    };

                    // Create THREE.Sprite
                    const charToDisplay = currentText[index % currentText.length]; 
                    const sprite = createSprite(charToDisplay, charSize, lineColor);
                    sprite.position.copy(charObj.pos);
                    streamGroup.add(sprite);
                    charObj.mesh = sprite;
                    
                    currentStream.chars.push(charObj); // 専用の配列に追加
                    points.push(charObj.pos);
                });

                // Create Line Geometry to connect characters
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const line = new THREE.Line(lineGeometry, lineMaterial);
                streamGroup.add(line);
                currentStream.lineGeometry = lineGeometry; // Geometryへの参照をオブジェクトに保存

                streamGroup.userData = { stream: currentStream }; 
                globalStreamGroup.add(streamGroup);
                characterSets.push(currentStream); // 専用のストリームオブジェクトを格納
            }
        }

        /**
         * 全ての要素セット内の要素を更新し、移動させます。
         * @param {number} deltaTime - 前フレームからの経過時間 (ms)。
         */
        function updateCharacters(deltaTime) {
            // フレームレートに依存しないようにスケーリング
            const speedScale = deltaTime / FIXED_FPS_FACTOR; 

            const resetZ = -400; // Z座標のループ開始位置
            const amplitudeMultiplier = 2.0;

            // characterSetsの要素は { chars: [], lineGeometry: ... } のオブジェクト
            characterSets.forEach(stream => {
                if (stream.chars.length === 0) return;
                
                // Line Geometryのposition属性配列を取得
                const positions = stream.lineGeometry.attributes.position.array;
                
                stream.chars.forEach((char, index) => { // stream.chars を反復処理
                    // 動きの時間を更新
                    char.time += char.frequency * globalSpeedFactor * speedScale;

                    // 揺らぎ成分の計算
                    let subtleY = 0;
                    switch (char.type) {
                        case 0: subtleY = Math.sin(char.time * 2) * (char.amplitude * 0.5 * amplitudeMultiplier); break;
                        case 1: subtleY = Math.cos(char.time * 0.5) * (char.amplitude * 0.8 * amplitudeMultiplier); break;
                        case 2: subtleY = (Math.random() - 0.5) * 0.5 * amplitudeMultiplier * Math.sin(char.time); break;
                    }
                    
                    // Z軸の移動 (Fast Scroll Speed)
                    const speed = char.baseVx * globalSpeedFactor;
                    char.pos.z += speed * speedScale; 

                    // Y位置に揺らぎを加算
                    char.pos.y = char.baseY + subtleY;
                    
                    // X位置にわずかなノイズを加算し、揺らぎを表現
                    char.pos.x = char.initialPos.x + Math.sin(char.time * 0.3) * 5; 

                    // カメラを通り過ぎたらZ座標をリセットし、ループさせる
                    if (char.pos.z > 300) {
                        char.pos.z = resetZ; 
                        // グローバル定数 INITIAL_X_SPREAD を使用してX位置をリセット
                        char.initialPos.x = Math.random() * INITIAL_X_SPREAD - INITIAL_X_SPREAD / 2;
                        char.pos.x = char.initialPos.x;
                        char.pos.y = char.initialPos.y;
                        char.time = Math.random() * 100; // 動きの開始時間をランダムにリセット
                    }

                    // 3Dメッシュの位置を更新
                    char.mesh.position.copy(char.pos);

                    // Line Geometryの頂点データを更新
                    positions[index * 3] = char.pos.x;
                    positions[index * 3 + 1] = char.pos.y;
                    positions[index * 3 + 2] = char.pos.z;
                });
                
                // 頂点データが変更されたことをThree.jsに通知
                stream.lineGeometry.attributes.position.needsUpdate = true;
            });
            
            // グループ全体の回転を加えて、さらなるダイナミズムを追加
            globalStreamGroup.rotation.y += 0.0001 * globalSpeedFactor * speedScale;
            globalStreamGroup.rotation.z += 0.00005 * globalSpeedFactor * speedScale;
        }

        /**
         * メインのアニメーションループ
         */
        function animate(time) {
            requestAnimationFrame(animate);

            // デルタタイムの計算
            const deltaTime = time - lastTime;
            lastTime = time;

            // カメラ操作の更新
            controls.update(); 
            
            // 全ての要素の位置を更新
            updateCharacters(deltaTime); 
            
            // シーンのレンダリング
            renderer.render(scene, camera);
        }

        /** ウィンドウリサイズハンドラ */
        window.addEventListener('resize', () => {
            D_W = window.innerWidth;
            D_H = window.innerHeight;
            
            camera.aspect = D_W / D_H;
            camera.updateProjectionMatrix();
            renderer.setSize(D_W, D_H);
        });
        
        // --- 初回起動 ---
        window.onload = function() {
            setupThreeJs();
            animate(0); 
        }

    </script>
</body>
</html>

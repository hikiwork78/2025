<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>xmasstream</title>
    <!-- Tailwind CSSの読み込み (UIは削除しましたが、CSSスタイルとして残します) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-black': '#000000',
                        'primary-white': '#FFFFFF',
                    },
                }
            }
        }
    </script>
    <!-- Google Font: Cutive Mono (文字描画に使用) -->
    <link href="https://fonts.googleapis.com/css2?family=Cutive+Mono&display=swap" rel="stylesheet">
    
    <!-- Three.jsの読み込み -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControlsの読み込み (カメラ操作用) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <style>
        /* 背景を白、描画を黒のモノクローム設定 */
        body {
            background-color: #FFFFFF; /* 背景色を白 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            margin: 0;
            overflow: hidden;
            font-family: 'Cutive Mono', monospace;
            cursor: grab; /* ドラッグ操作を促すカーソル */
            position: relative;
        }
        canvas {
            display: block;
        }
        /* UIオーバーレイは削除されました */
    </style>
</head>
<body>
    <!-- 3Dレンダリングコンテナ -->
    <div id="container"></div>

    <script>
        // --- Three.js グローバル変数 ---
        let scene, camera, renderer, controls;
        let D_W, D_H;
        let charSize; 
        
        // --- アートワーク グローバル変数 ---
        let characterSets = []; 
        // UIが削除されたため、テキストをハードコードします。
        let currentText = "FAST SCROLL MODE"; 
        let globalStreamGroup; 
        
        // --- デルタタイム関連変数 ---
        let lastTime = 0;
        const FIXED_FPS_FACTOR = 1000 / 60; 

        // --- アニメーション状態 ---
        // Fast Scroll (状態 1) に固定
        // UI操作がないため、この変数は実質的に固定値として機能します。
        const animationState = 1; 
        const globalSpeedFactor = 4.0; // Fast Scroll の速度係数に固定

        // カラーパレット (背景: 白, ライン/文字: 黒)
        const lineColor = 0x000000; 
        

        /**
         * 文字を描画したテクスチャを持つ THREE.Sprite を作成する
         * Create a THREE.Sprite with a texture of the given character.
         * @param {string} text - The character to render.
         * @param {number} size - Base size in 3D space.
         * @param {number} color - Text color (0xRRGGBB).
         * @returns {THREE.Sprite}
         */
        function createSprite(text, size, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            
            // Sprite resolution
            const resolution = 64; 
            canvas.width = resolution;
            canvas.height = resolution;

            // Use 'Cutive Mono' font
            context.font = `bold ${resolution * 0.8}px 'Cutive Mono', monospace`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            
            // Set draw color to black
            const hexColor = '#' + color.toString(16).padStart(6, '0');
            context.fillStyle = hexColor;

            // Draw the character
            context.fillText(text, resolution / 2, resolution / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.minFilter = THREE.LinearFilter;

            const material = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
            });

            const sprite = new THREE.Sprite(material);
            sprite.scale.set(size * 2, size * 2, 1); 
            return sprite;
        }


        /**
         * 3D環境のセットアップ
         * Setup the Three.js environment.
         */
        function setupThreeJs() {
            D_W = window.innerWidth;
            D_H = window.innerHeight;

            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, D_W / D_H, 0.1, 1000);
            camera.position.z = 150; 

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(D_W, D_H);
            renderer.setClearColor(0xFFFFFF); // Background color set to white
            
            const container = document.getElementById('container');
            while (container.firstChild) {
                container.removeChild(container.firstChild);
            }
            container.appendChild(renderer.domElement);

            // OrbitControls for camera interaction
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;

            // Global group for all streams
            globalStreamGroup = new THREE.Group();
            scene.add(globalStreamGroup);
            
            // Determine base size
            charSize = Math.max(1.0, Math.min(3.0, D_H / 200)); 
            
            initializeCharacters();
        }

        /**
         * 要素セット（ストリーム）を3D空間に初期配置します。
         * Initializes character streams in 3D space.
         */
        function initializeCharacters() {
            // Clear existing objects
            globalStreamGroup.clear();
            characterSets = [];

            // If text is empty, stop.
            if (currentText.trim() === "") {
                return;
            }

            const charLength = currentText.length;
            const numStreams = 15; // Increased density
            const depthRange = 500; 
            const initialXSpread = 250; 

            // Line Material (black, low opacity for thin appearance)
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: lineColor, 
                linewidth: 1, 
                transparent: true, 
                opacity: 0.15 
            });

            for (let i = 0; i < numStreams; i++) {
                const streamGroup = new THREE.Group();
                const currentSet = [];
                
                // Random initial Z and X position for the whole stream
                const initialZOffset = Math.random() * depthRange - depthRange / 2;
                const initialXOffset = Math.random() * initialXSpread - initialXSpread / 2;

                // Character generation and placement
                currentText.split('').forEach((char, index) => {
                    // Y position is offset within the stream
                    const initialY = (index - charLength / 2) * charSize * 2.5; 
                    
                    // Base speed (0.05 to 0.25)
                    const baseSpeed = 0.05 + Math.random() * 0.2; 
                    
                    // Amplitude (subtle movement)
                    const amplitude = Math.random() * 0.5 + 0.2; 
                    const frequency = 0.01 + Math.random() * 0.02; 
                    const movementType = Math.floor(Math.random() * 3); // For subtle movement variation

                    const charObj = {
                        char: char, 
                        pos: new THREE.Vector3(initialXOffset, initialY, initialZOffset),
                        baseY: initialY,  
                        baseVx: baseSpeed,
                        time: Math.random() * 100, 
                        amplitude: amplitude,
                        frequency: frequency,
                        type: movementType,
                        initialPos: new THREE.Vector3(initialXOffset, initialY, initialZOffset),
                        mesh: null // 3D Object (Sprite)
                    };

                    // Create THREE.Sprite
                    const charToDisplay = currentText[index % currentText.length]; 
                    const sprite = createSprite(charToDisplay, charSize, lineColor);
                    sprite.position.copy(charObj.pos);
                    streamGroup.add(sprite);
                    charObj.mesh = sprite;
                    
                    currentSet.push(charObj);
                });

                // Create Line Geometry to connect characters
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(currentSet.map(c => c.pos));
                const line = new THREE.Line(lineGeometry, lineMaterial);
                streamGroup.add(line);
                currentSet.lineGeometry = lineGeometry; 

                streamGroup.userData = { stream: currentSet }; 
                globalStreamGroup.add(streamGroup);
                characterSets.push(currentSet);
            }
        }

        /**
         * 全ての要素セット内の要素を更新し、移動させます。
         * Updates and moves all characters in all sets.
         * @param {number} deltaTime - Time elapsed since the last frame (ms).
         */
        function updateCharacters(deltaTime) {
            // Scaling factor for frame-rate independence
            const speedScale = deltaTime / FIXED_FPS_FACTOR; 

            const resetZ = -300; 
            const amplitudeMultiplier = 2.0; // Fast Scroll's higher amplitude

            characterSets.forEach(set => {
                if (set.length === 0) return;
                
                const positions = set.lineGeometry.attributes.position.array;
                
                set.forEach((char, index) => {
                    // Update time for subtle movement
                    char.time += char.frequency * globalSpeedFactor * speedScale;

                    // Calculate subtle movement component (subtleY is higher in fast scroll)
                    let subtleY = 0;
                    switch (char.type) {
                        case 0: subtleY = Math.sin(char.time * 2) * (char.amplitude * 0.5 * amplitudeMultiplier); break;
                        case 1: subtleY = Math.cos(char.time * 0.5) * (char.amplitude * 0.8 * amplitudeMultiplier); break;
                        case 2: subtleY = (Math.random() - 0.5) * 0.5 * amplitudeMultiplier; break;
                    }
                    
                    // --- Fast Scroll Mode (fixed) ---
                    
                    // Z movement (Fast Speed)
                    const speed = char.baseVx * globalSpeedFactor;
                    char.pos.z += speed * speedScale; 

                    // Y position is base coordinate + subtle movement
                    char.pos.y = char.baseY + subtleY;
                    
                    // Add slight random noise to X position
                    char.pos.x += (Math.random() - 0.5) * 0.05 * globalSpeedFactor * speedScale; 

                    // Loop back when passing the camera (Z > 300)
                    if (char.pos.z > 300) {
                        char.pos.z = resetZ; 
                        char.pos.x = char.initialPos.x + (Math.random() - 0.5) * 50;
                        char.pos.y = char.initialPos.y;
                        char.time = Math.random() * 100; // Reset time for randomized movement start
                    }

                    // Update 3D mesh position
                    char.mesh.position.copy(char.pos);

                    // Update Line Geometry vertices
                    positions[index * 3] = char.pos.x;
                    positions[index * 3 + 1] = char.pos.y;
                    positions[index * 3 + 2] = char.pos.z;
                });
                
                // Notify Three.js that vertices have changed
                set.lineGeometry.attributes.position.needsUpdate = true;
            });
        }

        /**
         * メインのアニメーションループ
         * Main animation loop.
         */
        function animate(time) {
            requestAnimationFrame(animate);

            // Calculate delta time
            const deltaTime = time - lastTime;
            lastTime = time;

            // Update camera controls
            controls.update(); 
            
            // Update all element positions
            updateCharacters(deltaTime); 
            
            // Render the scene
            renderer.render(scene, camera);
        }

        // --- UI操作ロジック ---
        // テキスト入力UIが削除されたため、関連関数も削除されます。

        /** ウィンドウリサイズハンドラ */
        window.addEventListener('resize', () => {
            D_W = window.innerWidth;
            D_H = window.innerHeight;
            
            camera.aspect = D_W / D_H;
            camera.updateProjectionMatrix();
            renderer.setSize(D_W, D_H);
        });
        
        // --- 初回起動 ---
        window.onload = function() {
            setupThreeJs();
            animate(0); 
        }

    </script>
</body>
</html>
